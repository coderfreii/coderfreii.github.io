## mysql

##### 事务

​			原子性 A

​			一致性 C

​			隔离性 I   

​			持久性 D

MySQL事务的ACID，一致性是最终目的。 

保证一致性的措施有： 

A原子性：靠undo log来保证（异常或执行失败后进行回滚）。 

D持久性：靠redo log来保证（保证当MySQL宕机或停电后，可以通过redo log最终将数据保存至磁盘中）。 

I隔离性：事务间的读写靠MySQL的锁机制来保证隔离，事务间的写操作靠MVCC机制（快照读、当前读）来保证隔离性。 

C一致性：事务的最终目的，即需要数据库层面保证，又需要应用层面进行保证。



###### 事务的隔离界别

+ 未提交读（READ UNCOMMITTED）。（脏读）
  + 另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据（脏读）。
+ 提交读（READ COMMITTED）。（不可重复读 概念上包括幻读）
  + 本事务读取到的是最新的数据（其他事务提交后的）。问题是，在同一个事务里，前后两次相同的SELECT会读到不同的结果（不重复读）。在同一个事务生命周期内，也就是这个事务还未提交之前。如果另外一个事务，对数据进行了编辑(update)或者删除(delete)操作。那么A事务就会读取到。简单理解，就是在一个事务生命周期内，多次查询数据，每次都可能查出来的不一样。
+ 可重复读（REPEATABLE READ）（解决了不可重复读中除了幻读的部分， 幻读新插入数据）。
  + 在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象。幻读的结果其实和不可重复读是一样的表现，差异就在于，不可重复读，主要是针对其他事务进行了编辑(update)和删除(delete)操作。而幻读主要是针对插入(insert)操作。也就是在一个事务生命周期内，会查询到另外一个事务新插入的数据。
  + 在可重复读中，该sql第一次读取到数据后，就将这些数据加锁（悲观锁），其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。
  +  RR隔离级别下为了解决“幻读”问题：“快照读”依靠MVCC控制，“当前读”通过间隙锁解决
+ 串行化（SERIALIZABLE）。
  + 读操作会隐式获取共享锁，可以保证不同事务间的互斥。
  + 需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。	





**MVCC**  快照读

就是==多版本并发控制==。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。

为什么需要MVCC呢？数据库通常使用锁来实现隔离性。最原生的锁，锁住一个资源后会禁止其他任何线程访问同一个资源。但是很多应用的一个特点都是读多写少的场景，很多数据的读取次数远大于修改的次数，而读取数据间互相排斥显得不是很必要。所以就使用了一种读写锁的方法，读锁和读锁之间不互斥，而写锁和写锁、读锁都互斥。这样就很大提升了系统的并发能力。之后人们发现并发读还是不够，又提出了能不能让读写之间也不冲突的方法，就是读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据。当然快照是一种概念模型，不同的数据库可能用不同的方式来实现这种功能。



**InnoDB与MVCC**

+ MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。

+ 其他两个隔离级别够和MVCC不兼容, 
  + 因为 READ UNCOMMITTED 总是读取最新的数据行, 而不是符合当前事务版本的数据行。
  + SERIALIZABLE 则会对所有读取的行都加锁。

**Redo log, bin log, Undo log**

InnoDB中通过undo log实现了数据的多版本，而并发控制通过锁来实现。

undo log除了实现MVCC外，还用于事务的回滚。MySQL Innodb中存在多种日志，除了错误日志、查询日志外，还有很多和数据持久性、一致性有关的日志。

binlog，是mysql服务层产生的日志，常用来进行数据恢复、数据库复制，常见的mysql主从架构，就是采用slave同步master的binlog实现的, 另外通过解析binlog能够实现mysql到其他数据源（如ElasticSearch)的数据复制。

redo log记录了数据操作在物理层面的修改，mysql中使用了大量缓存，缓存存在于内存中，修改操作时会直接修改内存，而不是立刻修改磁盘，当内存和磁盘的数据不一致时，称内存中的数据为脏页(dirty page)。为了保证数据的安全性，事务进行中时会不断的产生redo log，在事务提交时进行一次flush操作，保存到磁盘中, redo log是按照顺序写入的，磁盘的顺序读写的速度远大于随机读写。当数据库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行事务提交修改数据。这样实现了事务的原子性、一致性和持久性。

undo log: 除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它记录了修改的反向操作，比如，插入对应删除，修改对应修改为原来的数据，通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC。



##### 读的两中方式

快照读

select

和

当前读（加锁读）

select ... lock in share mode

select ... for update

insert

update

delete

##### 快照读没有完全解决幻读？

是的，MySQL没有完全解决快照读下的幻读问题。（当前读完全解决了幻读）

可以做这个实验：

1. 当前DB已有id 5, 10, 15三条数据。
2. 事务A查询id < 10的数据，可以查出一行记录id = 5
3. 事务B插入id = 6的数据
4. 事务A再查询id < 10的数据，可以查出一行记录id = 5，查不出id = 6的数据（读场景，解决了幻读）
5. 事务A可以更新/删除id = 6的数据，不能插入id = 6的数据（写场景，幻读不彻底）

这个很好理解，MySQL虽然通过MVCC的版本号来解决了读场景下的幻读，但对于上面第5步那种写场景的情况，其实是无能为力的，因为MVCC毕竟是无锁实现。

所以如果后续要对数据进行写操作，还是**通过for update语句上锁**比较稳妥，不然就可能会出现上面第5步那样的问题。



##### 乐观锁 自己实现  添加版本号字段 

##### 锁机制（悲观锁）

###### 服务级别锁：

###### 表锁

查询当前表锁

~~~sql
LOCK TABLES test_product  READ,test_user WRITE;

show status like "%lock%";

show OPEN TABLES where In_use > 0;
~~~

显式

+ Lock Tables....Read不会阻塞其他线程对表数据的读取。
+ Lock Tables....Read会阻塞其他线程对数据变更。
+ Lock Tables....Read不允许对表进行更新操作(新增、删除也不行)，并且不允许访问未被锁住的表。
+ Lock Tables....Write会阻塞其他线程对数据读和写。
+ Lock Tables....WRITE允许对被锁住的表进行增删改查，但不允许对其他表进行访问。

　全局读锁其实就相当于用读锁同时锁住所有表。如果当前线程拥有某个表的写锁，则获取全局写锁的时候会报错。如果其他线程拥有某张表的写锁，则全局读锁会阻塞等待其他表释放写锁。

###### InnoDB锁

###### 行锁

InnoDB的行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件进行数据检索，Innodb才使用行级锁。

否则，将使用表锁（锁住索引的所有记录）。此表锁非彼表锁

###### **共享锁（S）与排它锁 （X）**

###### **共享锁**

> 又称之为 读 锁，简称 s 锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据库，但是只能读不能修改；

加锁方式：

select * from users where id = 1 lock in share mode;

释放方式：

rollback/commit;

举例：

当手动为select语句加上共享锁之后，在其它会话中我们对该条数据执行update 操作 ，会阻塞，这就是说，加了共享锁的数据，只能被其他事务读取，但是不能被修改

###### **排它锁**

> 又称为写锁，简称 X 锁，排它锁不能与其他锁并存，如一个事务获取了一个数据行的排它锁，其他事务就不能再获取改行的锁（包括共享锁和排它锁），只有当前获取了排它锁的事务可以对数据进行读取和修改（此时其他事务要读取数据可从快照获取）

加锁方式：

delete update  insert 默认加排他锁

select * from users where id = 1 for update;

释放方式：

rollback/commit;

举例：

其它事务获取共享锁 获取排他锁 都会阻塞



#### **意向共享锁(IS)和意向排他锁(IX)**

##### **意向共享锁**

表示事务准备给数据行加入共享锁，也就是说一个数据行在加共享锁之前必须先取得该表的IS锁。

##### **意向排他锁**

表示事务准备给数据行加入排它锁，也就是说一个数据行加排它锁之前必须先取得该表的IX锁。

**意向锁是InnoDB数据操作之前自动加的，不需要用户干预**

**意向锁是表级锁**

关于这两个锁的实际演示例子本文鉴于篇幅便不再赘述，感兴趣的可以根据上边描述的共享锁和排他锁演示过程自己体验一遍，我们常说，好记性不如烂笔头，看百遍还不如自己动手撸一遍来的痛快！

这两个意向锁存在的意义是：

> 当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速的返回，告知该表不能启用表锁（也就是会锁住对应会话），不必遍历行锁提高了，加锁的效率。



#### **行锁的算法**

行锁锁的是索引上的索引项

只有通过索引条件进行数据检索，Innodb才使用行级锁。否则，将使用表锁（锁住索引的所有记录）

- 临键锁 Next-Key locks 当sql执行按照索引进行数据的检索时，查询条件为范围查找（between and < > 等等）并有数据命中，则测试SQL语句加上的锁为Next-Key locks,锁住索引的记录区间加下一个记录区间，这个区间是左开右闭的
  - （Next-Key locks 是   Record Lock 和 gap lock 的组合  防止插入幻读和不可重复读 ）
- 间隙锁 Gap : 当记录不存在时，临键锁退化成Gap 在上述检索条件下，如果没有命中记录，则退化成Gap锁，锁住数据不存在的区间（左开右开）
  - (防止插入 造成幻读)
- 记录锁 Record Lock :唯一性索引 条件为精准匹配，退化成Record锁 当SQL执行按照唯一性（Primary Key,Unique Key）索引进行数据的检索时，查询条件等值匹配且查询的数据存在，这是SQL语句上加的锁即为记录锁Record locks,锁住具体的索引项。（防止不可重复读）